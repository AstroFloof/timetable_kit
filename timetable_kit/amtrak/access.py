#! /usr/bin/env python3
# amtrak/access.py
# Part of timetable_kit
# Copyright 2021, 2022 Nathanael Nerode.  Licensed under GNU Affero GPL v.3 or later.

"""
Make various dicts from station code to various station accessibility features.

Requires local copy of Amtrak stations database: That local copy is generated by "json_stations.py download"
This has very similar code to baggage.py
"""

from io import StringIO  # for parsing JSON
import json

import pandas as pd

from timetable_kit.amtrak.json_stations import (
    load_stations_json,
    load_station_details,
)

# These are mine
from timetable_kit.debug import debug_print
from timetable_kit.feed_enhanced import FeedEnhanced

# FIXME: this should be relative to something.
# base_dir = Path(__file__).parent
# station_stats_dir = base_dir / "station_stats"
# stations_csv_path = station_stats_dir / "json_stations.csv"
# bad_stations_path = base_dir / "bad_stations.csv"

# This is a global filled on first use
accessible_platform_dict = None
inaccessible_platform_dict = None


def station_has_inaccessible_platform(station_code: str) -> bool:
    """
    Does the station explicitly have an inaccessible platform?

    This excludes stations which don't say either way.

    Constructs and caches the data on first call.
    Requires that the JSON stations database already be downloaded.
    """
    if inaccessible_platform_dict is None:
        make_accessibility_dicts()
    return inaccessible_platform_dict[station_code]


def station_has_accessible_platform(station_code: str) -> bool:
    """
    Does this station explicitly have an accessible platform?

    This excludes stations which don't say either way.

    Constructs and caches the data on first call.
    Requires that the JSON stations database already be downloaded.
    """
    if accessible_platform_dict is None:
        make_accessibility_dicts()
    return accessible_platform_dict[station_code]


def make_accessibility_dicts() -> None:
    """
    Make dicts which map from station code to accessibility status.

    These are globals within this module.
    """
    stations_json = load_stations_json()

    # Have to set up a StringIO wrapper
    stations_json_as_file = StringIO(stations_json)
    # This line just works!
    stations = pd.io.json.read_json(stations_json_as_file, orient="records")
    station_list = stations["code"].array

    global accessible_platform_dict
    global inaccessible_platform_dict
    accessible_platform_dict = {}
    inaccessible_platform_dict = {}

    for code in station_list:
        station_details_json = load_station_details(code)
        if station_details_json in ["{}", "{}\n"]:  # Bad station
            debug_print(1, "Bad station details for", code, ": assuming nothing")
            accessible_platform_dict[code] = False
            inaccessible_platform_dict[code] = False
        else:
            parsed_json = json.loads(station_details_json)
            # Exactly five tabs in details, one of which is "accessibility".
            access_json = parsed_json["accessibility"]

            # First pass through for accessible platform:
            for x in access_json:
                # Each element looks like {"feature", "blahblahblah"}.
                if "feature" in x:
                    if x["feature"] in ["Accessible platform"]:
                        accessible_platform_dict[code] = True
                        break
            else:  # Did not break out of the loop
                accessible_platform_dict[code] = False

            # Second pass through for inaccessible platform:
            for x in access_json:
                if "feature" in x:
                    if x["feature"] in ["No accessible platform"]:
                        inaccessible_platform_dict[code] = True
                        break
            else:  # Did not break out of the loop
                inaccessible_platform_dict[code] = False

            if accessible_platform_dict[code] and inaccessible_platform_dict[code]:
                # Should never happen
                print("Platform both accessible and inaccessible at", code)
    print("Built accessible platform dicts")
    # Finally out of the loop
    return


def station_wheelchair_boarding_gtfs_code(station_code: str) -> int:
    """
    What is the correct GTFS wheelchair boarding code number for the station?
    0 = unknown
    1 = accessible, for at least some services
    2 = explicitly inaccessible
    Does the station explicitly have an inaccessible platform?

    Constructs and caches the data on first call.
    Requires that the JSON stations database already be downloaded.
    """
    if accessible_platform_dict is None or inaccessible_platform_dict is None:
        make_accessibility_dicts()

    # There's some weirdness with station codes which aren't in the JSON database,
    # notably CBN (Canadian border).  These should be treated as "unknown".
    # So use "get" to default to "unknown" for anything not in the database.

    if inaccessible_platform_dict.get(station_code):
        return 2
    elif accessible_platform_dict.get(station_code):
        return 1
    else:
        return 0


def combine_wheelchair_boarding_columns(old: int, new: int) -> int:
    """
    Combine two wheelchair boarding GTFS codes.
    Prefer "old", but if "old" is 0, use "new".
    """
    if old:
        return old
    else:
        return new


def patch_add_wheelchair_boarding(feed: FeedEnhanced):
    """
    Patch an Amtrak GTFS feed to add the wheelchair boarding information from Amtrak's JSON stations database.

    Fix feed in place.
    """
    new_stops = feed.stops
    if "wheelchair_boarding" in feed.stops.columns:
        # This happens in the Frankenfeed for the Maple Leaf
        debug_print(1, "Wheelchair boarding already present in GTFS")
        # Rename the old wheelchair_boarding column to wb_old
        new_stops.columns = [
            "wb_old" if name == "wheelchair_boarding" else name
            for name in new_stops.columns
        ]
        debug_print(3, new_stops)
        # Assign a new column by applying the test function to the stop_id column
        new_stops["wb_json"] = new_stops["stop_id"].map(
            station_wheelchair_boarding_gtfs_code
        )
        debug_print(3, new_stops)
        # Construct the new, combo column
        new_stops["wheelchair_boarding"] = new_stops.apply(
            lambda row: combine_wheelchair_boarding_columns(
                row["wb_old"], row["wb_json"]
            ),
            axis=1,
        )

        # Dispose of the intermediate calculations
        new_stops = new_stops.drop(columns=["wb_old", "wb_json"])
        print(new_stops)
    else:
        # Simple version, no pre-existing column
        # Assign a new column by applying the test function to the stop_id column
        new_stops["wheelchair_boarding"] = new_stops["stop_id"].map(
            station_wheelchair_boarding_gtfs_code
        )

    debug_print(1, "GTFS patched for wheelchair boarding")
    debug_print(2, new_stops)

    # Now patch the feed in place.
    feed.stops = new_stops
    return


# TESTING
if __name__ == "__main__":
    from timetable_kit.debug import set_debug_level

    set_debug_level(2)
    from timetable_kit.initialize import initialize_feed

    master_feed = initialize_feed("./gtfs")
    patch_add_wheelchair_boarding(master_feed)
