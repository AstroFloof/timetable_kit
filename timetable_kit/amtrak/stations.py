#! /usr/bin/env python3
# amtrak/station_info.py
# Part of timetable_kit
# Copyright 2021, 2022, 2023 Tiernan Johnson and Nathanael Nerode.  Licensed under GNU Affero GPL v.3 or later.

"""
Make various dicts from station code to whether the station is a train station or a bus stop.
Utility routines to style Amtrak station names as HTML or text.
Make a dict from station code to checked baggage status (present / not present).

Also, runnable as a script to get the same information.

Requires local copy of Amtrak stations database: That local copy is generated by "json_stations.py download"
"""
import json
import sys

import pandas as pd

# For parsing the HTML pages
from lxml import html

from timetable_kit.amtrak.connecting_services_data import (
    connecting_services_dict,
    get_all_connecting_services,
)
from timetable_kit.amtrak.json_stations import (
    load_stations_json,
    load_station_details_html,
    load_station_details,
)
from timetable_kit.connecting_services import get_connecting_service_logo_html
from timetable_kit.debug import debug_print, set_debug_level
from timetable_kit.generic_agency.station_info import AgencyStationInfo

# This is a map from what we might see in the web page,
# to the key information in the form:
# [train or bus, shelter type]
# Since train_or_bus is used in detecting Amtrak's ADA compliance,
# if it's a train station for not-Amtrak-only, we consider it a bus stop.
station_types_decoding_map: dict[str, tuple[int, int]] = {
    # This is the most basic curbside bus stop
    "Bus Stop - Curbside Bus Stop only (no shelter)": (0, 0),
    # Misprinted at LVP and SQM:
    "Curbside Bus Stop only (no shelter)": (0, 0),
    # This is too, but when at a transit center?
    "Bus Station - Curbside Bus Stop only (no shelter)": (0, 0),
    # I don't know why this is different: wheelchair access maybe?
    # I think it's off-street, but usually at random restaurants
    "Bus Stop - Platform only (no shelter)": (0, 0),
    # This is only found at WBT (West Oakland BART).
    # You can wait inside the station.
    "Bus Station - Platform only (no shelter)": (0, 1),
    # Ferry Terminals are inevitably used as bus stops by Amtrak
    # This is only found at BRI (Bristol, RI)
    "Ferry Terminal - Platform only (no shelter)": (0, 0),
    # There are several of these.  What even IS this?
    # It's used at Green Bay, but also at Metrolink stations in California
    # and Morgan Hill Caltrain station in California
    # And Green Bay, Blacksburg, VA, Woodburn, OR, and Wheatland, Wyoming Arby's.
    "Bus Stop - Platform with Shelter": (0, 1),
    # This is only found at WIC (Wichita, Kansas).  Why?
    "Bus Station - Platform with Shelter": (0, 1),
    # These are bus stops with a third-party (resort etc.) waiting room
    "Bus Stop - Station Building (with waiting room)": (0, 2),
    # These are proper transit center type bus stations
    "Bus Station - Station Building (with waiting room)": (0, 2),
    # Ferry Terminals are inevitably used as bus stops by Amtrak
    "Ferry Terminal - Station Building (with waiting room)": (0, 2),
    # This is only found at Livermore, CA (LIV).
    # It's a train station for someone else, not for Amtrak.
    "Train Station - Curbside Bus Stop only (no shelter)": (0, 0),
    # Typical rural train station
    "Train Station - Platform only (no shelter)": (1, 0),
    # Slightly better rural train station
    "Train Station - Platform with Shelter": (1, 1),
    # Nice train station
    "Train Station - Station Building (with waiting room)": (1, 2),
}

# "Major stations".  This is for timetable styling: making them bigger and bolder.
# This should really be per-timetable but this is a start
# (Empire doesn't call out NEC stations on connecting trains)
# (Vermonter only calls out NY and DC on NEC)
major_stations_list = (
    "BOS",  # NEC timetable stations first
    "NHV",
    "NYP",
    "NYG",  # Just in case there's a reroute
    "PHL",
    "WAS",
    "RVR",  # Virginia services.  Richmond Staples Mill + 3 terminuses
    # "LYH", Amtrak emphasized, I won't since Roanoake extension
    "NPN",
    "NFK",
    "RNK",
    "HAR",  # Keystone timetable
    "PGH",
    "ALB",  # Empire timetable
    "BFX",
    "TWO",  # Maple Leaf
    "MTR",  # Adirondack
    "ESX",  # Vermonter
    "SPG",
    "BTN",  # Ethan Allen Express: Burlington
    "RUD",  # Ethan Allen Express: Rutland
    "RGH",  # Carolinian/Piedmont
    "CLT",
    "ATL",  # Crescent
    "BHM",
    "NOL",
    #    "ALT", # Pennsylvanian -- I think I won't emphasize this one.
    "CVS",  # Cardinal
    "CIN",
    "IND",
    "CHI",
    "CLE",  # LSL / CL
    "TOL",
    "GRR",  # Michigan services
    "PTH",
    "DET",
    "PNT",
    "BTL",  # Amtrak didn't mark Battle Creek, but we should
    "CHM",  # CONO/Illini/Saluki
    "CDL",
    "MEM",
    "JAN",
    "STL",  # River Runner
    "KCY",
    "QCY",  # Quincy service
    "MKE",  # Hiawathas
    "SAN",  # California Coastal
    "OSD",  # Major connecting point, I'm adding this
    "LAX",
    "SBA",
    "SLO",
    "SJC",
    "OKJ",
    "SAC",
    "SKN",  # San Joaquins
    "BFD",
    "MSP",  # EB -- Amtrak emphasized nothing on EB, so I picked some
    "MOT",
    "HAV",
    "SPK",
    "PDX",
    "SEA",
    "DEN",  # CZ -- Amtrak didn't, I should
    "SLC",
    "EMY",  # CZ
    "ABQ",  # SWC -- Amtrak didn't
    "FLG",
    "DAL",  # TE -- Amtrak emphasized nothing, so I picked some
    "FTW",  # TE / Heartland Flyer
    "OKC",  # Heartland Flyer -- Amtrak emphasized nothing
    "SAS",  # TE/SL
    "HOS",  # SL -- Amtrak emphasized nothing, so I picked some
    "ELP",
    "TUS",
    "CHS",  # Palmetto -- Amtrak emphasized nothing, so I picked Charleston
    "SAV",  # Silver Service -- Amtrak emphasized nothing, so I picked some
    "JAX",
    "ORL",
    "TPA",
    "MIA",
    "WMA",  # Grand Canyon Railway -- Williams is major
    "GCN",  # Grand Canyon Village station is too long for the timetable if boldfaced,
    # ...but we patch the station name in code, elsewhere.
)


class AmtrakStationInfo(AgencyStationInfo):
    _train_or_bus_dict: dict = None
    _shelter_dict: dict = None
    _checked_baggage_dict: dict[str, bool] = None

    def station_has_checked_baggage(self, stop_id: str) -> bool:
        return self._checked_baggage_dict[stop_id]

    def has_shelter(self, station_code: str) -> bool:
        return self._shelter_dict[station_code]

    def is_train_station(self, station_code: str) -> bool:
        return self._train_or_bus_dict[station_code]

    def is_major_station(self, stop_id: str):
        """Is a station on the list of standard 'major stations' for Amtrak?"""
        return stop_id in major_stations_list

    def get_all_connecting_services(self, station_list: list[str]) -> list:
        # Maybe this could also be in this file, but the dict is pretty intrusively big
        return get_all_connecting_services(station_list)

    def station_name_to_multiline_text(self, station_name: str, major=False) -> str:
        """
        Produce pretty Amtrak station name for plaintext -- multi-line.

        Given an Amtrak station name in one of these two forms:
        Champaign-Urbana, IL (CHM)
        New Orleans, LA - Union Passenger Terminal (NOL)
        Produce a pretty-printable text version (possibly multiple lines)
        If "major", then make the station name bigger and bolder
        We want to avoid very long lines as they mess up timetable formats
        """
        if " - " in station_name:
            (city_state_name, second_part) = station_name.split(" - ", 1)
            (facility_name, suffix) = second_part.split(" (", 1)
            (station_code, _) = suffix.split(")", 1)
        else:
            facility_name = None
            (city_state_name, suffix) = station_name.split(" (", 1)
            (station_code, _) = suffix.split(")", 1)

        if major:
            enhanced_city_state_name = city_state_name.upper()
        else:
            enhanced_city_state_name = city_state_name

        enhanced_station_code = "".join(["(", station_code, ")"])

        if facility_name:
            enhanced_facility_name = "".join(["\n", " - ", facility_name])
        else:
            enhanced_facility_name = ""

        fancy_name = "".join(
            [
                enhanced_city_state_name,
                " ",
                enhanced_station_code,
                enhanced_facility_name,
            ]
        )
        return fancy_name

    # Same as default
    # def station_name_to_single_line_text(self, station_name: str, major=False) -> str:
    #    return super().station_name_to_single_line_text(station_name, major)

    def station_name_to_html(
        self, station_name: str, major=False, show_connections=True
    ) -> str:
        """
        Produce pretty Amtrak station name for HTML -- potentially multiline, and complex.

        Given an Amtrak station name in one of these two forms:
        Champaign-Urbana, IL (CHM)
        New Orleans, LA - Union Passenger Terminal (NOL)
        Produce a pretty-printable HTML version
        If "major", then make the station name bigger and bolder
        If "show_connections" (default True) then add links for connecting services (complex!)
        """

        if " - " in station_name:
            (city_state_name, second_part) = station_name.split(" - ", 1)
            (facility_name, suffix) = second_part.split(" (", 1)
            (station_code, _) = suffix.split(")", 1)
        else:
            facility_name = None
            (city_state_name, suffix) = station_name.split(" (", 1)
            (station_code, _) = suffix.split(")", 1)

        # Special cases for exceptionally long city/state names.
        # Insert line breaks.
        raw_city_state_name = city_state_name
        match raw_city_state_name:
            case "Grand Canyon Village, AZ":
                city_state_name = "Grand Canyon<br>Village, AZ"
            case "Essex Junction-Burlington, VT":
                city_state_name = "Essex Junction<br>-Burlington, VT"
            case "Lompoc-Surf, CA -Amtrak Station":
                city_state_name = "Lompoc-Surf, CA"
            # You would think you'd want to do St. Paul-Minneapolis,...
            # but there's plenty of horizontal space in the EB timetable
            # and no vertical space

        if major:
            enhanced_city_state_name = "".join(
                ["<span class=major-station >", city_state_name, "</span>"]
            )
        else:
            enhanced_city_state_name = "".join(
                ["<span class=minor-station >", city_state_name, "</span>"]
            )

        enhanced_station_code = "".join(
            ["<span class=station-footnotes>(", station_code, ")</span>"]
        )

        # It looks stupid to see "- Amtrak Station."
        # I know it's there to distinguish from bus stops, but come on.
        # Let's assume it's the Amtrak station unless otherwise specified.
        # Also saves critical vertical space on Empire Builder timetable.
        #
        # Also eliminate Providence's "Amtrak/MBTA Station";
        # saves critical space on NEC timetables, and we're indicating the MBTA connection
        # in another way anyway.
        if facility_name and facility_name not in [
            "Amtrak Station",
            "Amtrak/MBTA Station",
        ]:
            # By default, put the facility name on its own line
            br_for_facility_name = "<br>"
            if station_code in ["BOS", "BBY"]:
                # Save lines on some timetables by putting the facility code on the same line as the station
                # This is needed at Boston for the Richmond timetable
                # Consider at Toronto for the sheer number of connecting services on the next line
                br_for_facility_name = " "
            if station_code == "PHL":
                # facility_name == "William H. Gray III 30th St. Station"
                # Sorry, Mr. Gray, your name is too long
                facility_name = "30th St. Station"
            if station_code == "NYP":
                # facility_name == "Moynihan Train Hall"
                # Explain that this is Penn Station
                # We have the room because we're taking an extra line for connecting services
                facility_name = "Moynihan Train Hall at Penn Station"
            enhanced_facility_name = "".join(
                [
                    br_for_facility_name,
                    "<span class=station-footnotes>",
                    " - ",
                    facility_name,
                    "</span>",
                ]
            )
        else:
            enhanced_facility_name = ""

        # Connections.  Hoo boy.  Default to nothing.
        connection_logos_html = ""
        if show_connections:
            # Special-casing for certain stations with LOTS of connections
            if station_code in ["NYP", "SLC", "SNC", "OSD"]:
                # NYP has a long facility name and a lot of connections
                # SLC has connections with very long lines
                # On the Pacific Surfliner:
                # SNC (San Juan Capistrano), OSD (Oceanside)
                # have excessively wide connection logos
                # Grab an extra line in these cases
                # TWO (Toronto) has a lot of connections,
                # but Empire Service timetables have more width than length available
                connection_logos_html += "<br>"
            # station_code had better be correct, since we're going to look it up
            # stations with no entry in the dict are treated the same as
            # stations which have an empty list of connecting services
            connecting_services = connecting_services_dict.get(station_code, [])
            for connecting_service in connecting_services:
                # Note, this is "" if the agency is not found (but a debug error will print)
                # Otherwise it's a complete HTML code for the agency & its icon
                this_logo_html = get_connecting_service_logo_html(connecting_service)
                if this_logo_html:
                    # Add a space before the logo... if it exists at all
                    connection_logos_html += " "
                    connection_logos_html += this_logo_html
            # Initial implementation tucks all connecting services on the same line.
            # This seems to be working.

        fancy_name = "".join(
            [
                enhanced_city_state_name,
                " ",
                enhanced_station_code,
                enhanced_facility_name,  # Has its own space or <br> before it
                connection_logos_html,  # Has spaces or <br> before it as needed
            ]
        )
        if station_code in ["ANA", "OLT"]:
            # San Diego Old Town has a short station name and a long facility name,
            # but also several long connecting services.  So put connections on line one,
            # before the facility name line.
            # Same with Anaheim.
            fancy_name = "".join(
                [
                    enhanced_city_state_name,
                    " ",
                    enhanced_station_code,
                    enhanced_facility_name,  # Has its own space or <br> before it
                    connection_logos_html,  # Has spaces or <br> before it as needed
                ]
            )
        return fancy_name

    def _gather_station_info(self):
        """
        Make dicts which map from station code to train or bus, baggage status, and shelter or not.

        These are globals within this module.
        """
        stations_json = load_stations_json()

        # Believe it or not, this line JUST WORKS!!!!  Wow!
        stations = pd.io.json.read_json(stations_json, orient="records")
        station_list = stations["code"].array

        train_or_bus_dict: dict[str, bool] = {}
        shelter_dict: dict[str, bool] = {}

        for station_code in station_list:
            station_details_html = load_station_details_html(station_code)

            # This is the part where we use the lxml library.
            html_tree = html.fromstring(station_details_html)
            description_list: list[str] = html_tree.xpath(
                '//h5[@class="hero-banner-and-info__card_station-type"]/text()'
            )
            # For exotic reasons, the description is returned in a list.
            # This is usually a one-item list, but occasionally it comes out
            # as a multiple item list with duplicates.
            if not description_list:
                debug_print(1, "no description for", station_code)
                continue
            if len(description_list) > 1:
                debug_print(
                    1, "excess description for", station_code, ":", description_list
                )
                # Only happens at VBC, and the two descriptions are identical
            description = description_list[0]
            if description not in station_types_decoding_map:
                debug_print(
                    1, "unexpected description for", station_code, ":", description
                )
            else:
                (train_or_bus, _shelter) = station_types_decoding_map[description]
                train_or_bus_dict[station_code] = bool(train_or_bus)
                shelter_dict[station_code] = bool(shelter_dict)
        print("Station type dicts made.")

        self._train_or_bus_dict = train_or_bus_dict
        self._shelter_dict = shelter_dict

        checked_baggage_dict = {}

        # TODO: this is the same loop as above, so maybe this should be merged. Right now it's just pasted from the old baggage.py
        for code in station_list:
            station_details_json = load_station_details(code)
            if station_details_json in ["{}", "{}\n"]:  # Bad station
                debug_print(
                    2, "Bad station details for", code, ": assuming no checked baggage"
                )
                checked_baggage_dict[code] = False
            else:
                parsed_json = json.loads(station_details_json)
                # Exactly five tabs in details, one of which is "baggage".
                baggage_json = parsed_json["baggage"]

                # baggage_json is a list.
                # Each element looks like {"feature", "blahblahblah"}.
                if {
                    "feature": "Checked baggage service available "  # Yes, with the space
                } in baggage_json:
                    checked_baggage_dict[code] = True
                elif {
                    "feature": "No checked baggage service"  # No space here
                } in baggage_json:
                    checked_baggage_dict[code] = False
                else:
                    debug_print(
                        2, "No information for", code, ": assuming no checked baggage"
                    )
                    checked_baggage_dict[code] = False

        # Finally out of the loop
        self._checked_baggage_dict = checked_baggage_dict


# TESTING
# This accepts a station code and gives information about it
if __name__ == "__main__":
    set_debug_level(2)
    input_station_code = sys.argv[1].lower()
    station_info = AmtrakStationInfo()  # This should generate and cache data
    print(
        input_station_code,
        "is train station?",
        station_info.is_train_station(input_station_code),
        "has shelter?",
        station_info.has_shelter(input_station_code),
    )
    # This should use cached data
    print(station_info.station_has_checked_baggage("NYP"))
    print(station_info.station_has_checked_baggage("CHI"))
    print(station_info.station_has_checked_baggage("SYR"))
    print(station_info.station_has_checked_baggage("BON"))
